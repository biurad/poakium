<?php declare(strict_types=1);

/*
 * This file is part of Biurad opensource projects.
 *
 * @copyright 2022 Biurad Group (https://biurad.com/)
 * @license   https://opensource.org/licenses/BSD-3-Clause License
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Biurad\Loader\Files\Adapters;

/**
 * Reading and generating Ini files.
 *
 * @author Divine Niiquaye Ibok <divineibok@gmail.com>
 */
final class IniFileAdapter extends AbstractAdapter
{
    /** Separator for nesting levels of configuration data identifiers. */
    protected string $nestSeparator = '.';

    /**
     * Flag which determines whether sections are processed or not.
     *
     * @see https://www.php.net/parse_ini_file
     */
    protected bool $processSections = true;

    /** If true the INI string is rendered in the global namespace without sections. */
    protected bool $renderWithoutSections = false;

    public function supports(string $file): bool
    {
        return 'ini' === \strtolower(\pathinfo($file, \PATHINFO_EXTENSION));
    }

    /**
     * Set nest separator.
     *
     * @return self
     */
    public function setNestSeparator(string $separator)
    {
        $this->nestSeparator = $separator;

        return $this;
    }

    /**
     * Get nest separator.
     */
    public function getNestSeparator(): string
    {
        return $this->nestSeparator;
    }

    /**
     * Marks whether sections should be processed.
     * When sections are not processed,section names are stripped and section
     * values are merged.
     *
     * @see https://www.php.net/parse_ini_file
     */
    public function setProcessSections(bool $processSections): self
    {
        $this->processSections = $processSections;

        return $this;
    }

    /**
     * Get if sections should be processed
     * When sections are not processed,section names are stripped and section
     * values are merged.
     *
     * @see https://www.php.net/parse_ini_file
     */
    public function getProcessSections(): bool
    {
        return $this->processSections;
    }

    /**
     * Set if rendering should occur without sections or not.
     *
     * If set to true, the INI file is rendered without sections completely
     * into the global namespace of the INI file.
     */
    public function setRenderWithoutSectionsFlags(bool $withoutSections): self
    {
        $this->renderWithoutSections = (bool) $withoutSections;

        return $this;
    }

    /**
     * Return whether the writer should render without sections.
     */
    public function shouldRenderWithoutSections(): bool
    {
        return $this->renderWithoutSections;
    }

    /**
     * Reads configuration from INI data.
     *
     * @return array<int|string,mixed>
     *
     * @throws \RuntimeException
     */
    protected function processFrom(string $string): array
    {
        $ini = \parse_ini_string($string, $this->getProcessSections());
        \restore_error_handler();

        return $this->process($ini);
    }

    /**
     * Generates configuration in INI format.
     */
    protected function processDump(array $data): string
    {
        $class = __CLASS__;

        return "; generated by $class\n\n".$this->processConfig($data);
    }

    /**
     * Process data from the parsed ini file.
     *
     * @return array<int|string,mixed>
     */
    protected function process(array $data): array
    {
        $config = [];

        foreach ($data as $section => $value) {
            if (\is_array($value)) {
                if (\str_contains($section, $this->nestSeparator)) {
                    $sections = \explode($this->nestSeparator, $section);
                    $config = \array_merge_recursive($config, $this->buildNestedSection($sections, $value));
                } else {
                    $config[$section] = $this->processSection($value);
                }
            } else {
                $this->processKey($section, $value, $config);
            }
        }

        return $config;
    }

    /**
     * Process a section.
     *
     * @param array<string,string> $section
     *
     * @return array<int|string,mixed>
     */
    protected function processSection(array $section): array
    {
        $config = [];

        foreach ($section as $key => $value) {
            $this->processKey($key, $value, $config);
        }

        return $config;
    }

    /**
     * Process a key.
     */
    protected function processKey(string $key, mixed $value, array &$config): void
    {
        if (\str_contains($key, $this->nestSeparator)) {
            $pieces = \explode($this->nestSeparator, $key, 2);

            if ('' === $pieces[0] || '' === $pieces[1]) {
                throw new \RuntimeException(\sprintf('Invalid key "%s"', $key));
            }

            if (!isset($config[$pieces[0]])) {
                if ('0' === $pieces[0] && !empty($config)) {
                    $config = [$pieces[0] => $config];
                } else {
                    $config[$pieces[0]] = [];
                }
            } elseif (!\is_array($config[$pieces[0]])) {
                throw new \RuntimeException(\sprintf('Cannot create sub-key for "%s", as key already exists', $pieces[0]));
            }

            $this->processKey($pieces[1], $value, $config[$pieces[0]]);
        } else {
            $config[$key] = $value;
        }
    }

    /**
     * Process array into ini.
     */
    protected function processConfig(array $config): string
    {
        $iniString = '';

        if ($this->shouldRenderWithoutSections()) {
            $iniString .= $this->addBranch($config);
        } else {
            $config = $this->sortRootElements($config);

            foreach ($config as $sectionName => $data) {
                if (!\is_array($data)) {
                    $iniString .= $sectionName.' = '.$this->prepareValue($data)."\n";
                } else {
                    $iniString .= '['.$sectionName.']'."\n".$this->addBranch($data)."\n";
                }
            }
        }

        return $iniString;
    }

    /**
     * Add a branch to an INI string recursively.
     *
     * @param array $parents
     *
     * @return string
     */
    protected function addBranch(array $config, $parents = [])
    {
        $iniString = '';

        foreach ($config as $key => $value) {
            $group = \array_merge($parents, [$key]);

            if (\is_array($value)) {
                $iniString .= $this->addBranch($value, $group);
            } else {
                $iniString .= \implode($this->nestSeparator, $group)
                           .' = '
                           .$this->prepareValue($value)
                           ."\n";
            }
        }

        return $iniString;
    }

    /**
     * Prepare a value for INI.
     *
     * @throws \RuntimeException
     */
    protected function prepareValue($value): string|int|float
    {
        if (\is_int($value) || \is_float($value)) {
            return $value;
        }

        if (\is_bool($value)) {
            return $value ? 'true' : 'false';
        }

        if (!isset($value) || !\str_contains($value, '"')) {
            return '"'.$value.'"';
        }

        throw new \RuntimeException('Value can not contain double quotes');
    }

    /**
     * Root elements that are not assigned to any section needs to be on the
     * top of config.
     *
     * @return array<int|string,mixed>
     */
    protected function sortRootElements(array $config): array
    {
        $sections = [];

        // Remove sections from config array.
        foreach ($config as $key => $value) {
            if (\is_array($value)) {
                $sections[$key] = $value;
                unset($config[$key]);
            }
        }

        // Read sections to the end.
        foreach ($sections as $key => $value) {
            $config[$key] = $value;
        }

        return $config;
    }

    /**
     * Process a nested section.
     */
    private function buildNestedSection(array $sections, array $value): array
    {
        if (empty($sections)) {
            return $this->processSection($value);
        }

        $nestedSection = [];
        $first = \array_shift($sections);
        $nestedSection[$first] = $this->buildNestedSection($sections, $value);

        return $nestedSection;
    }
}
